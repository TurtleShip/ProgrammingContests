#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <string>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
using namespace std;

#define REP(i,a,b) for(int i=a; i < b; i++)
#define REPE(i, a, b) for(int i=a; i <=b; i++)
int INF = numeric_limits<int>::max();
int nINF = numeric_limits<int>::min();
typedef long long ll;
 
class FuzzyLife {
public:
	int survivingCells(vector <string>);
};

const int maxN = 55;
int nei[maxN][maxN]; //nei[i][j] = number of neighbors at grid(i,j)
int dr[8] = {-1,-1,-1,0,0,1,1,1};
int dc[8] = {-1,0,1,-1,1,-1,0,1};


int FuzzyLife::survivingCells(vector <string> grid) {
	
    //we pad dead cells
    for(int i=0; i < grid.size(); i++)
        grid[i] = "0" + grid[i] + "0";
    
    string deadRow = string(grid[0].size(), '0');
    grid.insert(grid.begin(), deadRow);
    grid.push_back(deadRow);
    
    int R = grid.size();
    int C = grid[0].size();
    
    memset(nei, 0, sizeof(nei));
    
    //update neighbors
    for(int r=1; r < R-1; r++)
        for(int c=1; c < C-1; c++)
            if(grid[r][c] == '1')
                for(int i=0; i < 8; i++)
                    nei[r + dr[i]][c + dc[i]]++;
    
    //decide what to do with '?'
    for(int r=1; r < R-1; r++)
        for(int c=1; c< C-1; c++)
            if(grid[r][c] == '?')
            {
                int dead = 0, alive = 0;
                //put decision in a vote
                for(int i=0; i < 8; i++)
                {
                    int nr = r + dr[i];
                    int nc = c + dc[i];
                    
                    if(grid[nr][nc] == '1')
                    {
                        if(nei[nr][nc] == 1) alive++;
                        if(nei[nr][nc] == 3) dead++;
                    }
                    else if(grid[nr][nc] == '0')
                    {
                        if(nei[nr][nc] == 2) alive++;
                        if(nei[nr][nc] == 3) dead++;
                    }
                }
                
                if(dead <= alive) 
                {
                    grid[r][c] = '1';
                    //update neighbors
                    for(int i=0; i < 8; i++)
                        nei[r+dr[i]][c+dc[i]]++;
                }
                else grid[r][c] = '0';
            }

    int res = 0;
    
    for(int r=0; r < R; r++)
        for(int c=0; c < C; c++)
            if( (grid[r][c] == '1' && (nei[r][c] == 2 || nei[r][c] == 3)) || (grid[r][c] == '0' && nei[r][c] == 3) )
                res++;âˆ‚
    
    return res;
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.4 (beta) modified by pivanof
bool KawigiEdit_RunTest(int testNum, vector <string> p0, bool hasAnswer, int p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	FuzzyLife *obj;
	int answer;
	obj = new FuzzyLife();
	clock_t startTime = clock();
	answer = obj->survivingCells(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p1 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p1;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <string> p0;
	int p1;
	
	{
	// ----- test 0 -----
	string t0[] = {"011","0?1","100"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 5;
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	string t0[] = {"101","0?0","101"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 4;
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	string t0[] = {"11","11"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 4;
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	string t0[] = {"111","1?1","111"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 8;
	all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	string t0[] = {"?11?","0110","1001","?11?"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 12;
	all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 5 -----
	string t0[] = {"00100","01010","10?01","01010","00100"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 12;
	all_right = KawigiEdit_RunTest(5, p0, true, p1) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// END KAWIGIEDIT TESTING


//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!
