#include <vector>
#include <list>
#include <map>
#include <set>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
using namespace std;

#define REP(i,a,b) for(int i=a; i < b; i++)
#define REPE(i, a, b) for(int i=a; i <=b; i++)
int INF = numeric_limits<int>::max();
int nINF = numeric_limits<int>::min();
typedef long long ll;
 
class MagicalSquare {
public:
	long long getCount(vector <string>, vector <string>);
};

long long MagicalSquare::getCount(vector <string> rowStrings, vector <string> columnStrings) {
	int rowSize[3];
    int colSize[3];
    ll ans = 0;
    
    REP(i,0,3)
    {
        rowSize[i] = rowStrings[i].size();
        colSize[i] = columnStrings[i].size();
    }
    
    /*
     brute force is too slow, so it is likely to get TLE.
     What we can do is to precalculate some operations that we are going to repeatedly.
     We compare substrings of rows and substrings of columns frequently.
     So precalculate this. 
     precal[z] [r][a] [c][b] = true if ( row[r].substr(a,z) == col[c].substr(b,z))
     */
    
    bool precal[55][3][55][3][55];
    memset(precal, false, sizeof(precal));
    REP(r,0,3)
    REP(c,0,3)
    REPE(z,0,50)
    for(int a=0; (a+z) <= rowSize[r]; a++)
        for(int b=0; (b+z) <= colSize[c]; b++)
    {
        precal[z][r][a][c][b] = (rowStrings[r].substr(a,z) == columnStrings[c].substr(b,z));
    }
    
    for(int a = 0; a <= rowSize[0]; a++)
        for(int b = 0; (a+b) <= rowSize[0]; b++)
            for(int d = 0; d <= rowSize[1]; d++)
                for(int e = 0; (d+e) <= rowSize[1]; e++)
                {
                    if( (a+d) > colSize[0] || (b+e) > colSize[1] ) continue;
                    
                    int c = rowSize[0] - a - b;
                    int f = rowSize[1] - d - e;
                    int g = colSize[0] - a - d;
                    int h = colSize[1] - b - e;
                    int i = rowSize[2] - g - h;
                    if(i != (colSize[2] - c - f)) continue;
                    
                    if(precal[a][0][0][0][0] && precal[d][1][0][0][a] && precal[b][0][a][1][0] && precal[e][1][d][1][b] && precal[c][0][a+b][2][0] && precal[f][1][d+e][2][c] && precal[g][2][0][0][a+d] && precal[h][2][g][1][b+e] && precal[i][2][g+h][2][c+f]) ans++;
 
                }
    return ans;
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.4 (beta) modified by pivanof
bool KawigiEdit_RunTest(int testNum, vector <string> p0, vector <string> p1, bool hasAnswer, long long p2) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p1[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	MagicalSquare *obj;
	long long answer;
	obj = new MagicalSquare();
	clock_t startTime = clock();
	answer = obj->getCount(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p2 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p2;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <string> p0;
	vector <string> p1;
	long long p2;
	
	{
	// ----- test 0 -----
	string t0[] = {"f","o","x"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"f","o","x"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 1ll;
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	string t0[] = {"x","x","x"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"x","","xx"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 3ll;
	all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	string t0[] = {"cd","cd","cd"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"dvd","dvd","dvd"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 0ll;
	all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	string t0[] = {"abab","ab","abab"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"abab","ab","abab"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 11ll;
	all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	string t0[] = {"qwer","asdf","zxcv"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"qaz","wsx","erdfcv"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 1ll;
	all_right = KawigiEdit_RunTest(4, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// END KAWIGIEDIT TESTING


//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!
