#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <string>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
using namespace std;

#define REP(i,a,b) for(int i=a; i < b; i++)
#define REPE(i, a, b) for(int i=a; i <=b; i++)
int INF = numeric_limits<int>::max();
int nINF = numeric_limits<int>::min();
typedef long long ll;
 
class ColorfulCards {
public:
	vector <int> theCards(int, string);
};

/* Sieve of Eratosthenes
   It generates all the primes from 2 to a given number n.
   It begins by assuming that all numbers are prime. It then takes the first prime number and removes all of its multiples.
   It then applies the same method to the next prime number.
   This is continued until all numbers have been processed.
   */
vector<bool> sieve(int n)
{
	vector<bool> primes(n+1);
	fill(primes.begin(), primes.end(), true);
	primes[0] = false;
	primes[1] = false;
	int m = (int)sqrt(n);
	
	for(int i=2; i <=m; i++)
		if(primes[i])
			for(int k= i*i; k <= n; k+=i)
				primes[k] = false;
	
	return primes;
}


/*
 Red = prime
 blue = not prime
 */
vector <int> ColorfulCards::theCards(int N, string colors) {
	
    vector<bool> primes = sieve(N);
    bool valid = true;
    int K = colors.size();
    vector<int> ans(K,0);
    
    for(int i = K-1; i >= 0; i--)
    {
        bool isRed = (colors[i] == 'R');
        if(N < 1)
        {
            valid = false;
            break;
        }
        if(i == 0)
        {
            if(isRed)
            {
                if(N > 2)
                {
                    valid = false;
                    break;
                }
                else ans[i] = 2;
            }
            else
            {
                if(N >= 4)
                {
                    valid = false;
                    break;
                }
                else ans[i] = 1;
            }
        }
        else
        {
            if(isRed)
            {
                while(!primes[N]) N--;
                ans[i] = N;
                N--;
            }
            else
            {
                while(primes[N]) N--;
                ans[i] = N;
                N--;
            }
        }
        cout<<"i : "<<i<<" => "<<ans[i]<<endl;
    }
    
    if(valid) return ans;
    else fill(ans.begin(), ans.end(), -1);
    return ans;
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.4 (beta) modified by pivanof
bool KawigiEdit_RunTest(int testNum, int p0, string p1, bool hasAnswer, vector <int> p2) {
	cout << "Test " << testNum << ": [" << p0 << "," << "\"" << p1 << "\"";
	cout << "]" << endl;
	ColorfulCards *obj;
	vector <int> answer;
	obj = new ColorfulCards();
	clock_t startTime = clock();
	answer = obj->theCards(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "{";
		for (int i = 0; int(p2.size()) > i; ++i) {
			if (i > 0) {
				cout << ",";
			}
			cout << p2[i];
		}
		cout << "}" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "{";
	for (int i = 0; int(answer.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << answer[i];
	}
	cout << "}" << endl;
	if (hasAnswer) {
		if (answer.size() != p2.size()) {
			res = false;
		} else {
			for (int i = 0; int(answer.size()) > i; ++i) {
				if (answer[i] != p2[i]) {
					res = false;
				}
			}
		}
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	int p0;
	string p1;
	vector <int> p2;
	
	{
	// ----- test 0 -----
	p0 = 5;
	p1 = "RRR";
	int t2[] = {2,3,5};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = 7;
	p1 = "BBB";
	int t2[] = {1,4,6};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = 6;
	p1 = "RBR";
	int t2[] = {-1,4,5};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	p0 = 58;
	p1 = "RBRRBRBBRBRRBBRRBBBRRBBBRR";
	int t2[] = {-1,-1,-1,-1,-1,-1,-1,-1,17,18,19,23,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,47,53};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	p0 = 495;
	p1 = "RBRRBRBBRBRRBBRRBBBRRBBBRR";
	int t2[] = {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	all_right = KawigiEdit_RunTest(4, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// END KAWIGIEDIT TESTING


//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!
