#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <string>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
using namespace std;

#define REP(i,a,b) for(int i=a; i < b; i++)
#define REPE(i, a, b) for(int i=a; i <=b; i++)
int INF = numeric_limits<int>::max();
int nINF = numeric_limits<int>::min();
typedef long long ll;
 
class TheBoringStoreDivTwo {
public:
	string find(string, string);
};

string maxStr(string, string);

string TheBoringStoreDivTwo::find(string John, string Brus) {
	
    int N = John.size();
    int M = Brus.size();
    
    if(N < 2 || M < 2) return "";
    
    string ans = "";
    
    for(int i=0; i < N-1; i++)
    {
        for(int j=i+1; j < N; j++)
        {
            for(int l = M-1; l >=1; l--)
            {
                for(int k= l-1; k >=0; k--)
                {
                    if(John[i] == John[j] && Brus[l] == Brus[k])
                    {
                        int a = i;
                        int b = j;
                        int c = k;
                        int d = l;
                        
                        while(a < j && b < N && John[a] == John[b])
                        {
                            a++;
                            b++;
                        }
                        
                        while(k < d && 0 <= c && Brus[c] == Brus[d])
                        {
                            d--;
                            c--;
                        }
                        
                        //so far, A==B  and C==D
                        string A = John.substr(i, a-i); //[i,a)
                        string B = John.substr(j, b-j); //[j,b)
                        string C = Brus.substr(c+1, k-c); //(c,k]
                        string D = Brus.substr(d+1, l-d); //(d,l]
                        // i < a < j < b   and  c < k < d < l
                        ans = maxStr(ans, A+C);
                        
                        /*
                         A + extra + C == B + extra + D
                         Case 1) extra from A ==> extra from D
                         case 2) extra from C ==> extra from B
                        
                         A + extra + D == B + extra + C
                         case 3) extra from A ==> extra from C
                         case 4) extra from D ==> extra from B
                         */
                        
                        
                        //Try all values between A and B
                        for(int lenA = 1; (a+lenA-1) < j; lenA++)
                        {
                            string extraA = John.substr(a, lenA);
                            
                            
                            //extra from D. case 1
                            if(k < (d-lenA+1) && Brus.substr(d-lenA+1, lenA) == extraA)
                                ans = maxStr(ans, A + extraA + C);
                            
                            //extra from C. case 3
                            if(0 <= (c-lenA+1) && Brus.substr(c-lenA+1, lenA) == extraA)
                                ans = maxStr(ans, A + extraA + D);
                        }
                        
                        //Try all values after B
                        for(int lenB = 1; (b+lenB-1) < N; lenB++)
                        {
                            string extraB = John.substr(b, lenB);
                            
                            //in a hurry. If things don't work, revisit
                            //extra from C. case 2
                            if(0 <= (c-lenB+1) && Brus.substr(c-lenB+1, lenB) == extraB)
                                ans = maxStr(ans, B + extraB + D);
                            
                            //extra from D. case 4
                            if(k < (d-lenB+1) && Brus.substr(d-lenB+1, lenB) == extraB)
                                ans = maxStr(ans, B + extraB + C);
                        }
                        
                        
                        
                    }
                    
                }
            }
        }
    }
    return ans;
}

string maxStr(string a, string b)
{
    if(a.size() != b.size())
    {
        if(a.size() > b.size()) return a;
        else return b;
    }
    if(a < b) return a;
    else return b;
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.4 (beta) modified by pivanof
bool KawigiEdit_RunTest(int testNum, string p0, string p1, bool hasAnswer, string p2) {
	cout << "Test " << testNum << ": [" << "\"" << p0 << "\"" << "," << "\"" << p1 << "\"";
	cout << "]" << endl;
	TheBoringStoreDivTwo *obj;
	string answer;
	obj = new TheBoringStoreDivTwo();
	clock_t startTime = clock();
	answer = obj->find(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "\"" << p2 << "\"" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "\"" << answer << "\"" << endl;
	if (hasAnswer) {
		res = answer == p2;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	string p0;
	string p1;
	string p2;
	
	{
	// ----- test 0 -----
	p0 = "StoreOfJohn";
	p1 = "StoreOfBrus";
	p2 = "or";
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = "JohnAndJohn";
	p1 = "John";
	p2 = "";
	all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = "JohnPlaysGames";
	p1 = "BrusAlsoPlays";
	p2 = "ays";
	all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	p0 = "abacaba";
	p1 = "abacabadabacaba";
	p2 = "abaabacaba";
	all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// END KAWIGIEDIT TESTING


//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!
