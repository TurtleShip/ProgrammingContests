#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <string>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
using namespace std;

#define REP(i,a,b) for(int i=a; i < b; i++)
#define REPE(i, a, b) for(int i=a; i <=b; i++)
int INF = numeric_limits<int>::max();
int nINF = numeric_limits<int>::min();
typedef long long ll;
 
class NewItemShopTwo {
public:
	double getMaximum(vector <string>);
};

struct info{
    double time;
    double cost;
    double prob;
    
    info(double t, double c, double p) : time(t) , cost(c), prob(p) {}
    
};

vector< vector<info> >cus;

/*
 Get expected value when customer "who" has not entered
 first "index" times
 */
double getExpValue(int index, int who)
{
    double p = 1.0;
    double value = 0.0;
    
    for(int i=0; i < index; i++)
        p -= (double)cus[who][i].prob;
    
    //conditional probability
    for(int i=index; i < cus[who].size(); i++)
        value += (double)cus[who][i].prob / p * (double)cus[who][i].cost;
    
    return value;
}

double NewItemShopTwo::getMaximum(vector <string> customers) {
	
    for(int i=0; i < 2; i++)
    {
        for(int j=0; j < customers[i].size(); j++)
            if(customers[i][j] == ',')
                customers[i][j] = ' ';
        
        vector<info> cur;
        stringstream ss;
        ss<<customers[i];
        double t,c,p;
        while(ss>>t>>c>>p)
        {
            cur.push_back( info(t,c,(p/100.0)) );
        }
        cus.push_back(cur);
    }
    
    double ans = 0.0;
    
    /*
     p1 = probability that customer 1 did not show up before 
     */
    int t1 = 0 , t2 = 0;
    double p1 = 1.0 , p2 = 1.0;
    
    //Go through each time
    /*
     Do not overthink this problem.
     Don't try to factor in possibility where magic sword is already sold
     at time h because expected value at that time willl simply be 0.
     => No merchadise, no profit.
     Just try to think what are the possibilities that customers still have not come, and what are expected values are
     */
    for(int h=0; h < 24; h++)
    {
        if((int)cus[0][t1].time == h)
        {
            //Either sell it or keep it
            ans += (cus[0][t1].prob / p1) * p1 * p2 * max(cus[0][t1].cost, getExpValue(t2, 1));
            p1 -= cus[0][t1].prob;
            t1++;
        }
        else if( (int)cus[1][t2].time == h)
        {
            ans += (cus[1][t2].prob / p2) * p1 * p2 * max(cus[1][t2].cost, getExpValue(t1, 0));
            p2 -= cus[1][t2].prob;
            t2++;
        }
    }
   
    return ans;

}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.4 (beta) modified by pivanof
bool KawigiEdit_RunTest(int testNum, vector <string> p0, bool hasAnswer, double p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	NewItemShopTwo *obj;
	double answer;
	obj = new NewItemShopTwo();
	clock_t startTime = clock();
	answer = obj->getMaximum(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p1 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = fabs(p1 - answer) <= 1e-9 * max(1.0, fabs(p1));
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <string> p0;
	double p1;
	
	{
	// ----- test 0 -----
	string t0[] = {"8,1,80 16,100,11","12,10,100"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 19.0;
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	string t0[] = {"8,1,80 16,100,11","12,10,90 13,30,5"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 19.4;
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	string t0[] = {"0,90,25 2,90,25 4,90,25 6,90,25","7,100,80"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 90.0;
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	string t0[] = {"0,90,25 2,90,25 4,90,25 6,90,25","7,100,95"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 95.0;
	all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	string t0[] = {"0,3,1 2,4,1 4,5,9 6,2,6 8,5,3 10,5,8 12,9,7 14,9,3","1,2,3 3,8,4 5,6,2 7,6,4 9,3,3 11,8,3 13,2,7 15,9,5"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 3.0692999999999997;
	all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// END KAWIGIEDIT TESTING


//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!
