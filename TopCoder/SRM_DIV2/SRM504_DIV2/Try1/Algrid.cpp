#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <string>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
using namespace std;

#define REP(i,a,b) for(int i=a; i < b; i++)
#define REPE(i, a, b) for(int i=a; i <=b; i++)
int INF = numeric_limits<int>::max();
int nINF = numeric_limits<int>::min();
typedef long long ll;
 
class Algrid {
public:
	vector <string> makeProgram(vector <string>);
};

/*
 (i)th bit is
 0 if it is black
 1 if it is white
 
 Black is lexiograhpcially smaller than White.

 Each row of output depends solely on 
 its previous row and the current row.
 
 We can calculate following and save info in mem
 mem[prev][output] = cur
 
 After filling all mem, all we have to do is 
 iterate each row in output and apply mem.
 
 Filling all members of mem will take (2^C) * (2^C) = 2^(2C) 
 where C number of elements in a row
 At worst case, this will take 2^32 ~ 4 * 10^9 . Too big...
 
 Note that we do not have to fill all members of prev.
 There are at most 15 candidates for "prev" (16 rows at most, but only iterate from 0 to (R-2)
 
 15 * 2^16 = 983,040 => Small enough
 */
 
vector <string> Algrid::makeProgram(vector <string> output) {
	
    int R = output.size();
    int C = output[0].size();
    
    //convert output into a bitmask for easy computation
    vector<int> bits;
    
    for(int i=0; i < R; i++)
    {
        int mask = 0;
        for(int j=0; j < C; j++)
            if(output[i][j] == 'W')
                mask |= (1<<(C-1-j));

        bits.push_back(mask);
    }
    
    vector<int>input;
    vector<string> ans;
    //first row is the same in both input and output
    input.push_back(bits[0]); 
    
    for(int r=0; r < R-1; r++)
    {
        //cout<<"r : "<<r<<"start"<<endl;
        //we try all possibilities for the next row, 
        //starting from lexiographically smallest one.
        int candi;
        bool found = false;
        for(candi = 0; candi < (1<<C); candi++)
        {
            int cur = candi;
           // cout<<"candi : "<<candi<<endl;
            
            bool isValid = true;
            //check validity of current candidate
            for(int c=(C-1); c > 0; c--)
            {
                int a = (bits[r]>>c) & 1;
                int b = (bits[r]>>(c-1)) & 1;
                
                //whte & white => Do nothing
                
                //Black, white => repaints cells black
                if(a == 0 && b == 1)
                {
                    cur &= ~(1 << c);
                    cur &= ~(1 << (c-1));
                }
                
                //white, black => repaint cells white
                if(a == 1 && b == 0)
                {
                    cur |= (1 << c);
                    cur |= (1 << (c-1));
                }
                
                //black, black => swap colors
                if(a == 0 && b  == 0)
                {
                    int fi = (cur>>c) & 1;
                    int se = (cur>>(c-1)) & 1;
                    
                    if(fi != se)
                    {
                        cur ^= 1<<c;
                        cur ^= 1<<(c-1);
                    }
                }
                
                /*
                 (c)th bit is not going to change.
                 Check this against output.
                 */
                if( (cur & (1<<c)) != (bits[r+1] & (1<<c)) )
                {
                    isValid = false;
                    break;
                }
                
                //check the last bit
                if(c == 1 && ( (cur & 1) != (bits[r+1] & 1) ) )
                    isValid = false;
            }
    
            if(isValid)
            {
                found = true;
                input.push_back(candi);
                break;
            }
        }
       // cout<<"r : "<<r<<" end"<<endl;
        if(!found) return ans;
    }
   // cout<<"transformation begin"<<endl;

    //transform input to ans
    for(int r=0; r < R; r++)
    {
        string cur = "";
        for(int c = (C-1); c >= 0; c--)
        {
            if(input[r] & (1<<c))
            {
                cur += "W";
            }
            else
                cur += "B";
        }
        ans.push_back(cur);
    }
    return ans;
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.4 (beta) modified by pivanof
bool KawigiEdit_RunTest(int testNum, vector <string> p0, bool hasAnswer, vector <string> p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	Algrid *obj;
	vector <string> answer;
	obj = new Algrid();
	clock_t startTime = clock();
	answer = obj->makeProgram(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "{";
		for (int i = 0; int(p1.size()) > i; ++i) {
			if (i > 0) {
				cout << ",";
			}
			cout << "\"" << p1[i] << "\"";
		}
		cout << "}" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "{";
	for (int i = 0; int(answer.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << answer[i] << "\"";
	}
	cout << "}" << endl;
	if (hasAnswer) {
		if (answer.size() != p1.size()) {
			res = false;
		} else {
			for (int i = 0; int(answer.size()) > i; ++i) {
				if (answer[i] != p1[i]) {
					res = false;
				}
			}
		}
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <string> p0;
	vector <string> p1;
	
	{
	// ----- test 0 -----
	string t0[] = {"WWWWWWW","WWWWWWB","BBBBBWW"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"WWWWWWW","WWWWWWB","BBBBBBB"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	string t0[] = {"BBBBB","WBWBW"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"BBBBB","WWBWB"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	string t0[] = {"BBBB","BBBB","BBWB","WWBB","BWBB"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1.clear() /*{}*/;
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	string t0[] = {"WWBBBBW","BWBBWBB","BWBBWBW","BWWBWBB"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	string t1[] = {"WWBBBBW","BBBBBWB","BBBBBBB","BBBWBBB"};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// END KAWIGIEDIT TESTING


//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!
