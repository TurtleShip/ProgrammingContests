#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <string>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
using namespace std;

#define REP(i,a,b) for(int i=a; i < b; i++)
#define REPE(i, a, b) for(int i=a; i <=b; i++)
int INF = numeric_limits<int>::max();
int nINF = numeric_limits<int>::min();
typedef long long ll;
 
class DengklekPaintingSquares {
public:
	int numSolutions(int, int);
};

//3^8 = 6561
int mod = 1000000007;
int mem[101][6561];
int R;
int C;

int pow3[9];
int get3[6561][9];
int set3[6561][9][3];


void preCompute()
{
    pow3[0] = 1;
    for(int i=1; i <= 8; i++)
        pow3[i] = 3 * pow3[i-1];
    
    for(int i=0; i < pow3[8]; i++)
        for(int j=0; j <= 8; j++)
            get3[i][j] = (i/pow3[j]) % 3;
    
    for(int i=0; i < pow3[8]; i++)
        for(int j=0; j <=8; j++)
            for(int k=0; k <= 2; k++)
                set3[i][j][k] = i + (k - get3[i][j]) * pow3[j];
}

/*
 Given current row is idx-th row,
 and the previous row has configuration of "mask",
 return number of valid configurations.
 
 i-th digit of "mask" will be 
 0 : if it is not colored.
 1 : if it is colored, and has odd number of neighbors.
 2 : if it is colored, and has even number of neighbors.
 */

int rec(int idx, int mask)
{
    int& res = mem[idx][mask];
    
    if(res != -1) return res;
    
    res = 0;
    
    if(idx == R)
    {
        /*
         Check validity of the "mask"
         Return 1 is if valid. Else return 0.
         */
        bool isValid = true;
        for(int i=0; i < C; i++)
            if(get3[mask][i] == 1) isValid = false;
        if(isValid) 
            res = 1;

        return res;
    }
    
    /* 
     try all configuration for the current row
     i-th bit of config is 0 if it is not colored,
     i-th bit of config is 1 if it is colored.
     */
    for(int config = 0; config < (1<<C); config++)
    {
        bool isValid = true;
        //check if the current configuration is valid
        //by looking at previous row's configuration, or "mask"
        for(int i=0; i < C; i++)
        {
            bool isColored = ((config>>i) & 1);
            if( (get3[mask][i] == 1 && !isColored) || ( get3[mask][i] == 2 && isColored) )
            {
                isValid = false;
                break;
            }
        }
        
        if(isValid)
        {
            int newConfig = 0;
            
            //make new configuration according to config
            for(int i=0; i < C; i++)
            {
                if( (config>>i) & 1)
                {
                    /* Look up, left, and right */
                    int sum = (get3[mask][i] != 0) ? 1 : 0;
                    
                    if(i > 0)
                        sum = sum + (( (config>>(i-1)) & 1) ? 1 : 0);
                    
                    if(i < C-1)
                        sum = sum + (( (config>>(i+1)) & 1) ? 1 : 0);
                    

                    if(sum%2 == 1) newConfig = set3[newConfig][i][1];
                    else newConfig = set3[newConfig][i][2];
                }
                else
                {
                    newConfig = set3[newConfig][i][0];
                }
            }
            res = (res + rec(idx+1, newConfig)) % mod;
        }
    }
  
    return (res % mod);
}


int DengklekPaintingSquares::numSolutions(int N, int M) {
    R = N;
    C = M;
    
    memset(mem, -1, sizeof(mem));
    
    preCompute();
    
	return rec(0,0);
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.4 (beta) modified by pivanof
bool KawigiEdit_RunTest(int testNum, int p0, int p1, bool hasAnswer, int p2) {
	cout << "Test " << testNum << ": [" << p0 << "," << p1;
	cout << "]" << endl;
	DengklekPaintingSquares *obj;
	int answer;
	obj = new DengklekPaintingSquares();
	clock_t startTime = clock();
	answer = obj->numSolutions(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p2 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p2;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	int p0;
	int p1;
	int p2;
	
	{
	// ----- test 0 -----
	p0 = 1;
	p1 = 1;
	p2 = 2;
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = 2;
	p1 = 2;
	p2 = 8;
	all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = 1;
	p1 = 3;
	p2 = 5;
	all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	p0 = 47;
	p1 = 7;
	p2 = 944149920;
	all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// END KAWIGIEDIT TESTING


//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!
