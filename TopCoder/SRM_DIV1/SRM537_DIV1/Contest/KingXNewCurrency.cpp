#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <string>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
using namespace std;

#define REP(i,a,b) for(int i=a; i < b; i++)
#define REPE(i, a, b) for(int i=a; i <=b; i++)
int INF = numeric_limits<int>::max();
int nINF = numeric_limits<int>::min();
typedef long long ll;
 
 //a and b cannot both be 0
int GCD(int a, int b)
{
	if(b==0) return a;
	return GCD(b, a%b);
}

int LCM(int a, int b)
{
	return b * a / GCD(a,b);
}

 
class KingXNewCurrency {
public:
	int howMany(int, int, int);
};


int KingXNewCurrency::howMany(int A, int B, int X) {
	
    if(A % X == 0 &&  B % X == 0)
        return -1;
    
    //A and B will be different
    if(A % X == 0) // B % X != 0
    {
        set<int> ans;
        
        for(int Y=1; Y <= B; Y++)
        {
            if(X == Y) continue;
            if(B % Y == 0) ans.insert(Y);
        }
        
        int x = X;
        while( x < B )
        {
            for(int Y = 1; Y <= (B-x); Y++)
                if( (B-x) % Y == 0) ans.insert(Y);
            
            x += X;
        }
        
        return ans.size();
    }
    
    if(B % X == 0) //A % X != 0
    {
        set<int> ans;
        
        for(int Y=1; Y <= A; Y++)
        {
            if(X == Y) continue;
            if(A % Y == 0) ans.insert(Y);
        }
        
        int x = X;
        while( x < A )
        {
            for(int Y = 1; Y <= (A-x); Y++)
                if( (A-x) % Y == 0) ans.insert(Y);
            
            x += X;
        }
        
        return ans.size();
    }
   
    //A % X != 0 && B % X != 0
    
    int gcd = GCD(A,B);
    
    set<int> ans;

    for(int Y = 1; Y <= gcd; Y++)
        if(A % Y == 0 && B % Y == 0)
            ans.insert(Y);
  
    vector<int> As;
    vector<int> Bs;
    
    As.push_back(A);
    Bs.push_back(B);
    
    int x = X;
    while(x < A)
    {
        As.push_back(A-x);
        x += X;
    }
    x = X;
    while(x < B)
    {
        Bs.push_back(B-x);
        x += X;
    }
    
    for(int Y = 1; Y <= min(A,B); Y++)
    {
        bool found = false;
        for(int i=0; !found && i < As.size(); i++)
        {
            for(int j=0; j < Bs.size(); j++)
            {
                if(As[i] % Y == 0 && Bs[i] % Y == 0)
                {
                    found = true;
                    ans.insert(Y);
                    break;
                }
            }
        }
    }
    
    return ans.size();
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.4 (beta) modified by pivanof
bool KawigiEdit_RunTest(int testNum, int p0, int p1, int p2, bool hasAnswer, int p3) {
	cout << "Test " << testNum << ": [" << p0 << "," << p1 << "," << p2;
	cout << "]" << endl;
	KingXNewCurrency *obj;
	int answer;
	obj = new KingXNewCurrency();
	clock_t startTime = clock();
	answer = obj->howMany(p0, p1, p2);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p3 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p3;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	int p0;
	int p1;
	int p2;
	int p3;
	
	{
	// ----- test 0 -----
	p0 = 5;
	p1 = 8;
	p2 = 5;
	p3 = 5;
	all_right = KawigiEdit_RunTest(0, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = 8;
	p1 = 4;
	p2 = 2;
	p3 = -1;
	all_right = KawigiEdit_RunTest(1, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = 7;
	p1 = 4;
	p2 = 13;
	p3 = 1;
	all_right = KawigiEdit_RunTest(2, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	p0 = 47;
	p1 = 74;
	p2 = 44;
	p3 = 2;
	all_right = KawigiEdit_RunTest(3, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	p0 = 128;
	p1 = 96;
	p2 = 3;
	p3 = 65;
	all_right = KawigiEdit_RunTest(4, p0, p1, p2, true, p3) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// END KAWIGIEDIT TESTING


//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!
