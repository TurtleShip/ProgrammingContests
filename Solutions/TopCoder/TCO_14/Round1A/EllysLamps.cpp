#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
using namespace std;

typedef long long ll; 

class EllysLamps {
public:
	int getMin(string lamps);
};

int EllysLamps::getMin(string lamps) {
	/*
	I looked at LayCurse's solution and understood it as below.

	Let's simplify problem.
	We have 3 possible grouping - group of 1 member, 2 members, and 3 members.
	
	Group of 1 member is useless, because we can always make it to 'N'
	
	In group of 2 members, we can have NN, YY, and NY.
	NN and YY will can always be put to NN regradless of configuration.
	However, if NY or YN, then we can force users to leave at least one of them to
	be 'Y' by having a configuration where clicking any of them toggles both of them.
	
	In group of 3 members, we can narrow our choices of configuration down to
	NNN and YYY.
		Reasonsing behind only considering NNN and YYY:
			IN group of 3 members, there is no configuation where we can force
			a user to leave 2 'Y' on. The reason is that if any sequence of clicks 
			lead to 2 'Y's, then the user can repeat the procedure to have
			2 'N's instead.
	NNN is useless because a user can just not do anything.
	In YYY, we can force a user to leave 1 'Y' on by having the below configuration
	index : 1 2 3
			Y Y Y
	Click 0 : Toggle 0 and 1
	Click 1 : Toggle 0 and 1
	Click 2 : Toggle 1 and 2
	

	Now the problem comes down to the below.
	Let dp[i] = the maximum number of 'Y's we can force a user to have by using
				[0, i-1] lamps, inclusive.
	dp[0] = 0 as our base case. [0, -1] => No lamps
	dp[i] >= dp[i-1] trivially.
	if( lamps[i] != lamps[i-1] ) {
		// Then we can put lamps[i] and lamps[i-1] in a group of 2 lamps
		dp[i+1] = max(dp[i+1], dp[i-1] + 1);
	}
	if( lamps[i-2] == 'Y' && lamps[i-1] == 'Y' && lamps[i] == 'Y') {
		// Then we can put lamps[i-2], lamps[i-1], and lamps[i] in a group of 3 lamps
		dp[i+1] = max(dp[i+1], dp[i-2] + 1);
	}
	
	Our answer will be dp[N]
	*/
	int N = lamps.size();
	int dp[N+1];
	dp[0] = 0;
	for(int i=0; i < N; i++) {
		dp[i+1] = dp[i];
		if(i-1 >= 0 && lamps[i-1] != lamps[i]) {
			dp[i+1] = max(dp[i+1], dp[i-1] + 1);
		}
		if(i-2 >= 0 && lamps[i-2] == 'Y' && lamps[i-1] == 'Y' && lamps[i] == 'Y') {
			dp[i+1] = max(dp[i+1], dp[i-2] + 1);
		}
	}

	return dp[N];
}
 
// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.4 (beta) modified by pivanof
bool KawigiEdit_RunTest(int testNum, string p0, bool hasAnswer, int p1) {
	cout << "Test " << testNum << ": [" << "\"" << p0 << "\"";
	cout << "]" << endl;
	EllysLamps *obj;
	int answer;
	obj = new EllysLamps();
	clock_t startTime = clock();
	answer = obj->getMin(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p1 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p1;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	string p0;
	int p1;
	
	{
	// ----- test 0 -----
	p0 = "YNNYN";
	p1 = 2;
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = "NNN";
	p1 = 0;
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = "YY";
	p1 = 0;
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	p0 = "YNYYYNNNY";
	p1 = 3;
	all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	p0 = "YNYYYYNYNNYYNNNNNNYNYNYNYNNYNYYYNY";
	p1 = 13;
	all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// END KAWIGIEDIT TESTING



//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!
