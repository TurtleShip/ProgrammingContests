#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <string>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
using namespace std;

#define REP(i,a,b) for(int i=a; i < b; i++)
#define REPE(i, a, b) for(int i=a; i <=b; i++)
int INF = numeric_limits<int>::max();
int nINF = numeric_limits<int>::min();
typedef long long ll;
 
class SlimeXResidentSlime {
public:
	int exterminate(vector <string>);
};

/*
 Look up editorial, and check if this problem borrows a concept from Traveling salesman
 1 <= R <= 50
 1 <= C <= 50
 
 There are only 9 digits.
 
 So there can be at most 9 slimes for valid cases.
 
 Let z = the highest digit.
 Then we can allow at most 'z' slimes for valid cases.
 
 There can not be more than 1 slime with '1'
 no more than 2 slimes with '2'
 
 
 Let's think of each cell where an undead slime resides as a node.
 The cost from the initial position to other cells are distance between them.
 
 Let maxDist = the farthest distance from node i to node j
 
 If maxDist >= z , return -1.
 Else, it would be optimal to go to the closest node with digit z, and 
 visit other nodes.

 */

vector<string> field;
int R;
int C;

struct Slime
{
    int time;
    int row;
    int col;
    
    Slime(int t, int r, int c) : time(t) , row(r), col(c) {}
};


int findDist(int sr, int sc, int er, int ec)
{
    int dr[4] = {1,-1,0,0};
    int dc[4] = {0,0,1,-1};
    bool chk[R][C];
    
    memset(chk, false, sizeof(chk));
    
    queue<int> Q;
    Q.push(sr);
    Q.push(sc);
    Q.push(0);
    chk[sr][sc] = true;
    while(!Q.empty())
    {
        int curR = Q.front(); Q.pop();
        int curC = Q.front(); Q.pop();
        int curTurn = Q.front(); Q.pop();
        
        if(curR == er && curC == ec)
            return curTurn;
        
        for(int i=0; i < 4; i++)
        {
            int nextR = curR + dr[i];
            int nextC = curC + dc[i];
            
            if(0 <= nextR && nextR < R && 0 <= nextC && nextC < C)
            {
                if(chk[nextR][nextC] || field[nextR][nextC] == '#') continue;
                
                chk[nextR][nextC] = true;
                Q.push(nextR);
                Q.push(nextC);
                Q.push(curTurn+1);
            }
        }
    }

    return -1;
}

int SlimeXResidentSlime::exterminate(vector <string> _field) {
    field = _field;
    R = field.size();
    C = field[0].size();
    
    int sr = 0, sc = 0;
    vector<Slime> nodes;

    //find slimes and me
    for(int r=0; r < R; r++)
    {
        for(int c=0; c < C; c++)
        {
            if(isdigit(field[r][c]))
            {
                nodes.push_back( Slime( field[r][c] - '0', r, c) );
            }
            else if(field[r][c] == '$')
            {
                sr = r; sc = c;
            }
        }
    }
    if(nodes.size() > 9) return -1;
    
    
    //make an adjacency matrix
    int N = nodes.size();
    int adj[N+1][N+1];
    for(int i=0; i < N; i++)
    {
        adj[i][i] = 0;
        for(int j=(i+1); j < N; j++)
        {
            adj[i][j] = adj[j][i] = findDist(nodes[i].row, nodes[i].col, nodes[j].row, nodes[j].col);
            if(adj[i][j] == -1) return -1;
        }
    }
    
    for(int i=0; i < N; i++)
        adj[i][N] = adj[N][i] = findDist(sr, sc, nodes[i].row, nodes[i].col);

    
    //try every combination.  9! is small enough to try them all
    vector<int> order;
    int ans = INF;
    for(int i=0; i < N; i++)
        order.push_back(i);
    
    do {
        //go from the last to the first to check if we have enough time
        int total = 0;
        bool valid = true;
        for(int i=0; i < N-1; i++)
        {
            total += adj[order[i]][order[i+1]];
            if(total >= nodes[order[i+1]].time)
            {
                valid = false;
                break;
            }
        }
        
        if(!valid || adj[order[N-1]][N] == -1) continue;
        
        total += adj[order[N-1]][N];
        ans = min(ans, total);

        
    } while( next_permutation(order.begin(), order.end()));

    
    if(ans != INF) return ans;
	return -1;
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.4 (beta) modified by pivanof
bool KawigiEdit_RunTest(int testNum, vector <string> p0, bool hasAnswer, int p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	SlimeXResidentSlime *obj;
	int answer;
	obj = new SlimeXResidentSlime();
	clock_t startTime = clock();
	answer = obj->exterminate(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p1 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p1;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <string> p0;
	int p1;
	
	{
	// ----- test 0 -----
	string t0[] = {"#1$",".2."};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 3;
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	string t0[] = {"$","1","1"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = -1;
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	string t0[] = {"$124"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 5;
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	string t0[] = {"$.#2","#..1"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 6;
	all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// END KAWIGIEDIT TESTING


//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!
