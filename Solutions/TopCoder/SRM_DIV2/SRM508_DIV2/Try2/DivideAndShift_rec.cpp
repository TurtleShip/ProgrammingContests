#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <string>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
using namespace std;

#define REP(i,a,b) for(int i=a; i < b; i++)
#define REPE(i, a, b) for(int i=a; i <=b; i++)
int INF = numeric_limits<int>::max();
int nINF = numeric_limits<int>::min();
typedef long long ll;
 
class DivideAndShift {
public:
	int getLeast(int, int);
};

//returns true if n is prime
bool isPrime(int n)
{
	if(n <= 1) return false;
	if(n == 2) return true;
	if(n%2 == 0)return false;
	int m = (int)sqrt(n);
	for(int i=3; i <=m; i+=2)
		if(n%i == 0)
			return false;
	return true;
}

/* Sieve of Eratosthenes
   It generates all the primes from 2 to a given number n.
   It begins by assuming that all numbers are prime. It then takes the first prime number and removes all of its multiples.
   It then applies the same method to the next prime number.
   This is continued until all numbers have been processed.
   */
int maxN = 1000000;
bool sieve[1000000 +1];

void makeSieve()
{
	fill(sieve, sieve + maxN + 1, true);
	sieve[0] = false;
	sieve[1] = false;
	int m = (int)sqrt(maxN);
	
	for(int i=2; i <=m; i++)
		if(sieve[i])
			for(int k= i*i; k <= maxN; k+=i)
				sieve[k] = false;
}

/*
 Given a strip, we can do one of the following
 1) perform shifting
 2) divide the strip into smaller component
 
 We can , and will check for (dividing => perform shifting)
 But how about (perform shifting => dividing)?
 We will get back to this issue later. ===!!!!~~~$$$###
 */
 int rec(int N, int M, int ops)
{
    //cout<<"N : "<<N<<" , M  : "<<M<<" , ops : "<<ops<<endl;
    if(M==1) return ops;
    if(sieve[N] || M ==2 || M == N) return (ops + 1);
    
    int res = ops + min(M-1, N-M+1);
    
    if(N%2 == 0)
        res = min(res, rec(N/2, (M%(N/2) == 0) ? N/2 : (M%(N/2)) , ops + 1));
    
    
    for(int i=3; i <= N; i+=2)
        if(N%i == 0 && sieve[i])
                res = min(res, rec(N/i , (M%(N/i) == 0) ? (N/i) : (M%(N/i)), ops + 1));
    
    return res;
}

int DivideAndShift::getLeast(int N, int M) {
	
    if(M==1) return 0;
    if(isPrime(N) || M == 2 || M == N) return 1;
    
    makeSieve();
    return rec(N,M,0);
}

// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.4 (beta) modified by pivanof
bool KawigiEdit_RunTest(int testNum, int p0, int p1, bool hasAnswer, int p2) {
	cout << "Test " << testNum << ": [" << p0 << "," << p1;
	cout << "]" << endl;
	DivideAndShift *obj;
	int answer;
	obj = new DivideAndShift();
	clock_t startTime = clock();
	answer = obj->getLeast(p0, p1);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p2 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p2;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	int p0;
	int p1;
	int p2;
	
	{
	// ----- test 0 -----
	p0 = 56;
	p1 = 14;
	p2 = 3;
	all_right = KawigiEdit_RunTest(0, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = 49;
	p1 = 5;
	p2 = 2;
	all_right = KawigiEdit_RunTest(1, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = 256;
	p1 = 7;
	p2 = 6;
	all_right = KawigiEdit_RunTest(2, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	p0 = 6;
	p1 = 1;
	p2 = 0;
	all_right = KawigiEdit_RunTest(3, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	p0 = 77777;
	p1 = 11111;
	p2 = 2;
	all_right = KawigiEdit_RunTest(4, p0, p1, true, p2) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// END KAWIGIEDIT TESTING


//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!
