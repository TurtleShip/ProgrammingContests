#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
using namespace std;

typedef long long LL;
#define pb(x) push_back(x)

const double EPS = 1e-8;

// return 0 if x == y,   -1 if x < y,    1 if x > y
int cmp(double x, double y = 0, double tol = EPS) {
	return (x <= y + tol) ? (x + tol < y) ? -1 : 0 : 1;
}

class GaussianElimination {

private:
	vector< vector<int> > augMat; // augmented matrix of variableMat + valMat
	int nE; // the total number of equations
	int nV; // the total number of variables
	bool isReduced;

public:
	GaussianElimination(const vector< vector<int> >& variableMat, const vector<int>& valMat) {
		// create an augmented matrix
		nE = variableMat.size();
		nV = variableMat[0].size();

		augMat.resize(nE);
		for(int i=0; i < nE; i++)
			augMat[i].resize(nV+1); // need one more column to store valMat

		for(int i=0; i < nE; i++) {
			for(int j=0; j < nV; j++)
				augMat[i][j] = variableMat[i][j];
			augMat[i][nV] = valMat[i];
		}

		isReduced = false; // not yet row-reduced
	}

	void printMatrix() {
		cout<<"Total equations : "<<nE<<" , Total variables : "<<nV<<endl;

		int variableWidth = 10;
		int decimalPrecision = 2;
		for(int i=0; i < nE; i++) {
			for(int j=0; j < nV; j++)		
				cout<<setw(variableWidth)<<fixed<<setprecision(decimalPrecision)<<augMat[i][j];
			cout<<" | "<<fixed<<setprecision(2)<<augMat[i][nV]<<endl;
		}
	}	

	// Calling it will permantntly change augMat to row-reduced echolon form. (REF)
	void performRowReduction() {

		int sourceEq = 0;

		// go through each variables
		for(int varIdx=0; varIdx < nV; varIdx++) {

			int targetEq = -1;
			
			for(int eqIdx=sourceEq; eqIdx < nE; eqIdx++) {
				if(augMat[eqIdx][varIdx] == 1) {
					targetEq = eqIdx;
					break;
				}
			}
			
			if(targetEq == -1) continue;

			// swap source equation with target equation
			augMat[sourceEq].swap(augMat[targetEq]);

			// Perform forward elimination phase
			for(int eqIdx = sourceEq+1; eqIdx < nE; eqIdx++) {
				if(augMat[eqIdx][varIdx] == 1) {
					// note that we apply to all variables AND the equation value
					for(int i=0; i <= nV; i++) {
						augMat[eqIdx][i] ^= augMat[sourceEq][i];
					}
				}
			}
			sourceEq++;
			// printMatrix();
		}

		isReduced = true;
	}

	int getRank() {
		if(!isReduced) {
			performRowReduction();
		}

		int rank = nE;
		bool isValid = true;
		for(int eqIdx = 0; isValid && eqIdx < nE; eqIdx++) {
			bool allZeros = true;
			// int sum = 0;
			for(int varIdx = 0; allZeros && varIdx < nV; varIdx++) {
				allZeros &= augMat[eqIdx][varIdx] == 0;
			}
			if(allZeros) {
				isValid &= augMat[eqIdx][nV] == 0;
				rank--;
			}
		}

		return isValid ? rank : -1;
	}
};


class PerfectSquare {
public:
	int ways(vector <int> x);
};

int PerfectSquare::ways(vector <int> x) {
	int n = sqrt(x.size());
	vector< vector<int> >equations;
	vector<int> ans;

	set<int> primes;
	for(int num : x) {
		
		if(num % 2 == 0) {
			primes.insert(2);
			while(num % 2 == 0) {
				num /= 2;
			}
		}

		int p = 3;
		while(num > 1) {
			if(num % p == 0) {
				primes.insert(p);
				while(num % p == 0)
					num /= p;
			}
			p += 2;
		}
	}

	int nV = x.size(); // total number of variables

	// equations for selecting odd number of elements for each row
	for(int r=0; r < n; r++) {
		vector<int> curEq(nV, 0);
		for(int c=0; c < n; c++) {
			curEq[r*n + c] = 1;
		}
		equations.pb(curEq);
		ans.pb(1); // we need odd number
	}

	// equations for selecting odd number of elements for each column
	for(int c=0; c < n; c++) {
		vector<int> curEq(nV, 0);
		for(int r=0; r < n; r++) {
			curEq[r*n + c] = 1;
		}
		equations.pb(curEq);
		ans.pb(1); // we need odd number
	}

	// equations for " the product of all selected elements must be a perfect square"
	for(set<int>::iterator it = primes.begin(); it!=primes.end(); it++) {
		vector<int> curEq(nV, 0);
		int prime = *it;
		
		for(int i = 0; i < nV; i++) {
			int mult = 0;
			int num = x[i];
			while(num % prime == 0) {
				mult++;
				num /= prime;
			}
			curEq[i] = mult % 2;
		}
		equations.pb(curEq);
		ans.pb(0); // we need even number of primes to have a perfect square
	}

	GaussianElimination ge(equations, ans);
	int rank = ge.getRank();

	if(rank == -1) return 0;

	int res = 1;
	for(int i=0; i < (nV - rank); i++)
		res = (res * 2) % 1000000007;

	return res;
}
 
// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.4 (beta) modified by pivanof
bool KawigiEdit_RunTest(int testNum, vector <int> p0, bool hasAnswer, int p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p0[i];
	}
	cout << "}";
	cout << "]" << endl;
	PerfectSquare *obj;
	int answer;
	obj = new PerfectSquare();
	clock_t startTime = clock();
	answer = obj->ways(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p1 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p1;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <int> p0;
	int p1;
	
	{
	// ----- test 0 -----
	int t0[] = {1,1,1,2};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 1;
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	int t0[] = {620,620,620,620};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 2;
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	int t0[] = {1,2,3,4,5,6,7,8,9};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 1;
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	int t0[] = {2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 0;
	all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 4 -----
	int t0[] = {2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 4;
	all_right = KawigiEdit_RunTest(4, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 5 -----
	int t0[] = {9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690,9699690};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 993282280;
	all_right = KawigiEdit_RunTest(5, p0, true, p1) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// END KAWIGIEDIT TESTING



//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!
