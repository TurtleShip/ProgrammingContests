#include <vector>
#include <list>
#include <map>
#include <set>
#include <queue>
#include <deque>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <ctime>
using namespace std;

typedef long long LL; 

class TheMagicMatrix {
public:
	int find(int N, vector <int> rows, vector <int> columns, vector <int> values);
};

LL MOD = 1234567891ll;

int getRank(vector< vector<int> > matrix, const int& modulo) {


	int nE = matrix.size();
	int nV = matrix[0].size() - 1;

	vector<bool> used(nE, false);

	// perform row-reduction
	for(int varIdx = 0; varIdx < nV; varIdx++) {

		// find the row with non-zero coefficient for this variable
		int pivotIdx = -1;
		for(int eqIdx=0; pivotIdx == -1 && eqIdx < nE; eqIdx++) {
			if(used[eqIdx]) continue;
			if(matrix[eqIdx][varIdx] != 0) {
				used[eqIdx] = true;
				pivotIdx = eqIdx;
			}
		}

		if(pivotIdx == -1) continue;

		for(int eqIdx = 0; eqIdx < nE; eqIdx++) {
			if(used[eqIdx]) continue;
			if(matrix[eqIdx][varIdx] == 0) continue;

			int coeff = 1;
			while((matrix[pivotIdx][varIdx] * coeff + matrix[eqIdx][varIdx]) % modulo != 0)
				coeff++;

			for(int i=0; i <= nV; i++) {
				matrix[eqIdx][i] = (matrix[pivotIdx][i] * coeff + matrix[eqIdx][i]) % modulo;
			}
		}
	}

	// rank is the number of independent rows(= nonzero rows)
	int rank = nE;
	bool isValid = true;
	for(int eqIdx = 0; isValid && eqIdx < nE; eqIdx++) {
		bool isAllZero = true;
		for(int varIdx = 0; isAllZero && varIdx < nV; varIdx++)
			isAllZero &= matrix[eqIdx][varIdx] == 0;

		if(isAllZero) {
			rank--;
			isValid &= matrix[eqIdx][nV] == 0;
		}
	}

	return isValid ? rank : -1;
}

void printMatrix(const vector< vector<int> > mat) {
	int nE = mat.size();
	int nV = mat[0].size() - 1;
	for(int i=0; i < nE; i++) {
		for(int j=0; j < nV; j++) {
			cout<<setw(5)<<mat[i][j];
		}
		cout<<" | "<<mat[i][nV]<<endl;
	}
}

// Finds x raised to n-th power modulo MOD
LL power(LL x, LL n){
    LL r = 1ll;
    while (n > 0) {
        if ( (n&1) == 1) {
            r = (r * x) % MOD;
        }
        x = (x * x) % MOD;
        n >>= 1;
    }
    return r;
}

int TheMagicMatrix::find(int N, vector <int> rows, vector <int> cols, vector <int> values) {
	
    if (N >= 11) {
        // The board is large enough for the formula to work:
        return (int) power(10, (N-1) * (N-1) - rows.size() + 1);
    }

	// 2N equations ( N for all rows, N for all columns ). N*N variables.
	// extra 1 column for the sum of each equation.
	vector< vector<int> > mat(2*N, vector<int>(N*N + 1, 0));
	for(int r=0; r < N; r++) {
		for(int c=0; c < N; c++) {
			mat[r][r*N+c] = 1;
			mat[N+c][r*N+c] = 1;
		}
	}

	for(int i=0; i < rows.size(); i++) {
		int varIdx = rows[i]*N + cols[i];

		mat[rows[i]][varIdx] = 0;
		mat[N+cols[i]][varIdx] = 0;
		// affects 2 equations. 1 for its row, and 1 for its column.
		mat[rows[i]][N*N] += values[i];
		mat[N + cols[i]][N*N] += values[i];
	}

	for(int i=0; i < 2*N; i++) {
		mat[i][N*N] = (10 - ((mat[i][N*N]) % 10)) % 10;
	}

	LL res = 0ll;
	int allVariables = N*N - rows.size();
	for(int dig = 0; dig <= 9; dig++) {
		
		int rank = getRank(mat, 10);

		int freeVariables = allVariables - rank;

		LL tmp = 1ll;
		for(int i=0; i < freeVariables; i++) {
			tmp = (tmp * 10ll) % MOD;
		}
		if(rank != -1) res = (res + tmp) % MOD;

		// update equations index
		for(int i=0; i < 2*N; i++)
			mat[i][N*N] = (mat[i][N*N] + 1) % 10;
	}

	return res;
}
 
// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.4 (beta) modified by pivanof
bool KawigiEdit_RunTest(int testNum, int p0, vector <int> p1, vector <int> p2, vector <int> p3, bool hasAnswer, int p4) {
	cout << "Test " << testNum << ": [" << p0 << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p1[i];
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p2.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p2[i];
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p3.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p3[i];
	}
	cout << "}";
	cout << "]" << endl;
	TheMagicMatrix *obj;
	int answer;
	obj = new TheMagicMatrix();
	clock_t startTime = clock();
	answer = obj->find(p0, p1, p2, p3);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p4 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p4;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	int p0;
	vector <int> p1;
	vector <int> p2;
	vector <int> p3;
	int p4;
	
	{
	// ----- test 0 -----
	p0 = 2;
	int t1[] = {0,1};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {1,0};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	int t3[] = {4,4};
			p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
	p4 = 10;
	all_right = KawigiEdit_RunTest(0, p0, p1, p2, p3, true, p4) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	p0 = 2;
	int t1[] = {0,1};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {1,0};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	int t3[] = {4,7};
			p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
	p4 = 0;
	all_right = KawigiEdit_RunTest(1, p0, p1, p2, p3, true, p4) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	p0 = 4;
	int t1[] = {0,0,0,1,2,2,2,3,3,3};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {0,1,2,3,0,1,2,0,1,2};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	int t3[] = {3,5,1,9,5,1,8,6,7,1};
			p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
	p4 = 2;
	all_right = KawigiEdit_RunTest(2, p0, p1, p2, p3, true, p4) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	p0 = 474;
	int t1[] = {44,77};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	int t2[] = {47,74};
			p2.assign(t2, t2 + sizeof(t2) / sizeof(t2[0]));
	int t3[] = {4,7};
			p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
	p4 = 83494518;
	all_right = KawigiEdit_RunTest(3, p0, p1, p2, p3, true, p4) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// END KAWIGIEDIT TESTING



//Powered by KawigiEdit 2.1.4 (beta) modified by pivanof!
